## async와 Deferred

- launch 코루틴 빌더를 통해 생성되는 코루틴은 기본적으로 작업 실행 후 결과를 반환하지 않음.
- async 코루틴 빌더를 통해 코루틴으로부터 결과값을 수신 받을 수 있음.
- launch 함수를 사용하면 결과값이 없는 코루틴 객체인 Job을 반환되는 것과 다르게 결과값이 있는 Deferred가 반환

1. async 사용해 결과값 수신하기
    1. async 코루틴 빌더는 결과값을 담아 반환하기 위해 Deferred<T> 타입의 객체를 반환
    2. 제네릭 타입을 지정하기 위해서는 Deferred에 명시적으로 타입을 설정하거나 async 블록의 반환값으로 반환할 결과값을 설정
   ```
   val deferred: Deferred<String> = async {
      delay(1000L
      return@async "Dummy" 
   }
   ```
2. await를 사용한 결과값 수신
    1. Deferred 객체는 미래의 어느 시점에 결과값이 반환 될 수 있음을 표현하는 코루틴 객체
    2. 코루틴이 실행 완료 될 때 결과값이 반환되므로 언제 결과값이 반환될지 정확히 알 수 없으며, 결과값이 필요하면 결과값이 수신될때까지 대기
    3. Deferred 객체는 결과값 수신 대기를 위해 await 함수를 제공.
    4. await 함수는 await 대상이 된 코루틴이 실행 완료 될 때까지 호출한 코루틴을 일시 중단하며, Deferred 코루틴이 실행 완료되면 결과값을 반환하고 호출부의 코루틴을 재개한다,.
    5. Job객체의 join 함수와 대기 한다는 점에서 유사하게 동작함.
    6. Deferred는 Job을 상속받아서 코루틴으로 부터 결과값을 반환 로직이 추가된 Job 객체의 자식 인터페이스이다.
    7. 따라서 join 함수, isActive, isCancelled, isCompleted 프로퍼티 등 job에서 사용하였던 모든걸 쓸수 있다.

3. 복수의 코루틴으로부터 결과값 수신
    1. await를 사용해 복수의 코루틴으로부터 결과값 수신하기
        1. await를 각각의 코루틴에서 호출하여 결과 처리
        2. 주의할것은 await 함수 호출을 마지막에 하여 코루틴이 각각의 스레드에서 구동할 수 있게 처리 할 것 (await 호출하는 순간 호출한 코루틴이 blocking 되므로)
        3. 각 코루틴이 동시에 실행될 수 있도록 만드는 것은 코루틴의 성능 측면에서 중요. 따라서 await 호출을 잘해야 성능을 최대치로 끌어낼 수 있다.
    2. awaitAll을 이용한 결과값 숫신
        1. awaitAll 함수는 Deferred 객체를 가변 인자로 받아서 처리함.
        2. 모든 결과가 수신될 때까지 호출부의 코루틴을 일시 중단 한 후 결과가 모두 수신 되면 Deferred List로 결과 리턴
        3. 제네릭 함수라 같은 결과 객체를 사용하는것만 묶을 수 있음.
    3. 컬렉션에 대해 awaitAll 사용하기
        1. 코루틴 라이브러리는 awaitAll 함수를 Collection 인터페이스 확장함수로 제공

4. withContext
    1. 코루틴 라이브러리에서 제공되는 withContext 함수를 사용하면 async-await 작업을 대체할 수 있다.
    2. 함수의 인자로 설정된 CoroutineContext 객체를 사용해 block 람다식을 실행하고, 완료되면 그결과를 반환
    3. async-await 쌍이 withContext 함수로 대체되면 중간에 Deferred 객체가 생성되는 부분이 없어지고, 결과가 바로 반환
    4. async-await 쌍은 새로운 코루틴을 생성해 작업을 처리하지만, withContext 함수는 실행 중이던 코루틴을 그대로 유지한 채 코루틴의 실행 환경만 변경해 작업을 처리
    5. withContext 함수가 호출되면 context 인자 값으로 변경 돼 실행되며, 이를 context switching 이라고 함.
    6. withContext 함수가 block 람다식을 벗어나면 다시 원래의 CoroutineContext 객체를 사용해 실행. (즉 동기적으로 실행됨.)
5. withContext 사용 시 주의 점.
    1. withContext 함수는 새로운 코루틴을 만들지 않기 때문에 하나의 코루틴에서 withContext 함수가 여러번 호출되면 순차적으로 실행.
    2. 즉, 복수의 독립적인 작업이 병렬로 실행돼야 하는 상황에 withContext를 사용 할 경우 성능상의 문제가 있을 수 있음.
    3. 코루틴을 병렬 처리를 위해서는 async-await 함수로 대체하여야 하고, awaitAll() 등을 통해 호출 순서를 잘 정의해야 함.
