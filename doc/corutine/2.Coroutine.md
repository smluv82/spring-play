## Coroutine 기본

- Coroutine은 협력 루틴이라는 단어 합성어임.
- 일시 중지했다가 나중에 중단된 지점부터 다시 시작할 수 있으며, 스레드의 한계를 타파하기 위함.
- 스레드의 한계는 스레드 블로킹 시 스레드가 대기 할 수 있다는 부분과 컨텍스트 스위칭의 비용 문제
- 코틀린은 언어 레벨에서 코루틴을 지원하지만 저수준 API만을 제공하여, 실제 개발에서는 코루틴 라이브러리 (kotlinx.coroutines)를 통해 제공함.
- runBlocking 함수를 통해 coroutine을 생성
- launch 함수를 통해서도 coroutine을 생성 할 수 있음.
- context = CoroutineName("{코루틴 명}") 을 입력하면 어떠한 코루틴인지 이름을 통해 알 수 있음. (로깅에서 활용 할 수 있을 듯)


- build.gradle.kts

```
val coroutinesVersion by extra("1.10.2")

implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:${coroutinesVersion}")
testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:${coroutinesVersion}")
```

- CoroutineTest.kt

```
fun firstCoroutine() {
    // 코루틴으로 메인스레드 블로킹 후 안쪽의 구문을 다 실행 후 메인 이후를 실행함
    // CoroutineName으로 코루틴 이름을 줄 수 있음.
    runBlocking(context = CoroutineName("runBlocking")) {
        println("[${Thread.currentThread().name}] Hello runBlocking")

        // launch는 추가적인 코루틴을 생성함.
        launch(context = CoroutineName("launch1")) {
            println("[${Thread.currentThread().name}] Hello launch#1")
        }

        launch(context = CoroutineName("launch2")) {
            println("[${Thread.currentThread().name}] Hello launch#2")
//                Thread.sleep(10000)
        }
    }

    println("[${Thread.currentThread().name}] Hello main")
}
```